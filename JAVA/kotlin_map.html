<!DOCTYPE html>
<html>
   <meta charset="UTF-8">
   <title>Kotlin map(v1.0) <!-- ignore --></title>
<head>
<script src="/IT_notes/map_v1.js"></script>
<link rel="stylesheet" type="text/css" href="/IT_notes/map_v1.css" />
</head>

<body>

<pre zoom>
<span xsmall>External Links</span>
@[https://kotlinlang.org/docs/reference/]
@[https://www.kotlindevelopment.com/]
  <a href="https://kotlinlang.org/docs/resources.html">More resources

  <a href="https://blog.kotlin-academy.com/multiplatform-native-development-in-kotlin-now-with-ios-a8546f436eec">Multiplatform Native Development In Kotlin</a>
  <a href="https://www.infoworld.com/article/3236419/development-tools/kotlin-frameworks-a-survey-of-jvm-development-tools.html#tk.ifw-infsb">Kotlin Frameworks survey</a>
  <a href="https://search.maven.org/#search%7Cga%7C3%7Corg.jetbrains.kotlin">org.jetbrains.kotlin artifacts at Maven Central</a>
  <a href="https://kotlinlang.org/docs/reference/kapt.html">Annotation Processing with Kotlin</a>:
    Annotation processors (see JSR 269) are supported in Kotlin with the kapt 
    compiler plugin. Being short, you can use libraries such as Dagger or Data 
    Binding in your Kotlin projects.
  <a href="https://github.com/Kotlin/kotlin-koans/tree/master/src">Kotlin Koans Excercises (Basic, Collections, conventions, properties, builders, generics)</a>

</pre>

<pre zoom { >
<span xsmall>Everything</span>
<span xsmall>is an</span>
<span xsmall>expresion</span>
  
// "if" are expresions and the last 
// expression is the value of the "if"-block:
val max = if (a ˂ b) {
    print("a Wins "); a 
} else {
    print("b Wins "); b 
}
<span xsmall>Inmutable values</span>
<span xsmall>and inferred types</span>
// Immediate inmutable assignment
val a: Int  = 1

// Inferred Int type (var mutable)
var count  = 5;
    count += 1;

<span xsmall>imports</span>
(similar to Python)
import bar.Bar as bBar

<span xsmall>Runtime</span>
<span xsmall>typecheck</span>
<span xsmall>('is')</span>
- Check types at runtime 
fun getStringLenght(obj: Any) {
  if (obj º isº String) {...} 
  if (obj º!isº String) {...}
}

<span xsmall>Equality</span>
val a = Class(param1, param2)
val b = Class(param1, param2)
a === b // returns false
a == b  // returns true

<span xsmall>standard</span>
<span xsmall>functions</span>
- no import required

ºApplyº
  helping funct. to init. objects:
// applies lambda to object and 
// returns same object
val task = Runnable { println("Running") }
Thread(task)º.applyº {
  setDaemon(true) }.start()


ºwithº to avoid repeated typing:
  class Turtle {
      turn(degrees: Double)
      forward(pixels: Double)
      ...
  }
  val myTurtle = Turtle()
  with(myTurtle) {
    penDown() ;
    for(i in 1..4) { 
      forward(100.0) ; turn(90.0) 
    }
  }

ºRun extension funcº
A closure is passed to run, which has the instance 
    as the receiver. The return value of the closure is used as the return value of run itself:
val outputPath = Paths.get("/user/home").run {
  val path = resolve("output")
  path.toFile().createNewFile()
  path
}
</pre>
</div>

<div groupv>
<pre zoom labels="performance">
<span xsmall>Lazy</span>
- wraps an expensive function call to be invoked when first required:
// expensive operation
fun readStringFromDatabase(): String = ... 
val lazyString = lazy { readStringFromDatabase() }
</pre>

<pre zoom >
<span xsmall>Use</span>
<span xsmall>(try-with-resources)</span>
val stream = Files.newInputStream(
    Paths.get("/some/file.txt"))
stream.buffered().
  reader()º.useº {
  reader -˃ 
    println(reader.readText()) 
}
</pre>
<pre zoom>
<span xsmall>repeat</span>
- Avoid "for" for simple operations
repeat(10, { println("Hello") })
</pre>
<pre zoom qa="architecture">
<span xsmall>Sequences</span>
<span xsmall>(Java streams)</span>
- Sequences are collections of unknown size
val charSequence: Sequence˂Char˃ =
  charArrayOf('a','b','c').asSequence()  //a,b,
val s1 : String  = charSequence.joinToString(",")

ºSequence generatorº
// NOTE: compared to collections, sequences
//     Oºdo NOT intermediate waste memoryº
var count = 10
val sequence = 
  generateSequence {
    (count--).takeIf { it &gt; 0 } 
}
</pre>
<pre zoom labels="qa">
<span xsmall>Require/assert/check</span>
fun neverEmpty(str: String) {
  require(str.length ˃ 0,
    { "String should not be empty" })
  println(str)
}
</pre>
</div> 

<div groupv>  
<pre zoom>
<span xsmall>Basic Types</span>
Long/Int/Short/Byte(64,32,16,8)
Boolean 
Chars
  val c: Char = '\uFF00' //  'a', '\b'
Strings
Arrays

ºexplicit Chart to Int conversionº
// alt: '0'..'9'.contains(c)
if (c in '0'..'9')  
  c.toInt() - '0'.toInt() 
else
  throw RuntimeException("...")

  Oºbitwise operationsº
val x = (1 shl 2) and 0x00FF
// (u)shl/(u)shr) bits:
//     (un)signed shift left/righ
// and/or/xor bits 
// inv()               :bitwise inversion

  Oºspecial optimized arraysº
// (Byte|Short|Int|...)Array
</pre>
<pre zoom>
<span xsmall>Regex</span>
@[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/]
// Matching and finding the groups in Kotlin:

val pattern = ºRegexº("[a-zA-Z]+([0-9]+)[a-zA-Z]+([0-9]+)[a-zA-Z]+")
val inputString = "ABcDEFG12345DiFKGLSG938SDsFSd"

val matchGroups = pattern.matchEntire(inputString)?.groupValues
while (matchGroups.find()) println(matchGroups.group())
</pre>

<pre zoom labels="qa">
<span xsmall>skip nulls</span>
@[https://kotlinlang.org/docs/reference/null-safety.html]
- nullables must be declared explicetelly
val nullableBob : String? = "abc"
nullableInstanceº?º.departmentº?º.headº?º.name 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Returns null if nullableInstance, department or head is null

val listWithNulls: List˂String?˃ = listOf("A", null)
for (item in listWithNulls) {
Bº/* "?.let" skips expression    º
Bº º block execution for nulls */*
  itemº?.letº { println(it) }
}

ºFiltering Nulls at list initializationº
º(Fix-fast)º
val intList: List˂Int˃ =
  listOf(1, 2, null, 4)
  º.filterNotNull()º


//*Assigning nullable to non-nullable   *
//*requires if (..!=null) ... else ...  *
val l: Int = ºif (b != null)º b.length else -1
ºor Elvis operator ?:º
val l = b?.length ?: -1

ºAbort/throw NullPointerE. if null presentº
  val name = node.getName()!!

ºSmartCastº
fun getName(): String? = ...
val name = getName()
if (name != null) {
  // here compiler knows name is not null
  println(name.length)
}
</pre>

<pre zoom labels="">
<span xsmall>Type alias</span>
- Rename type with alias.  The alias is simply replaced by the compiler. 
  This means that new types are not created or allocated, so we suffer
  no performance penalty. 
- typealias do ºNOTº increase type safety.
typealias Cache = HashMap˂String, Boolean˃
typealias Address = String
typealias FamilyName = String
</pre>

<pre zoom >
<span xsmall>when</span>
<span xsmall>(extended switch-case)</span>
fun describe(obj: Any = 1) :
    String = when(obj) {
  1            -˃ "One" 
  "Hello"      -˃ "Greeting" 
  is Long      -˃ "Long"
  in 32...128  -˃ "Is ASCII"
  !is String   -˃ "Not a string"
  "dog" in obj -˃ "Animal list"
  else         -˃ "Unknown"
}
</pre>
<pre zoom >
<span xsmall>try/catch </span>
<span xsmall>as expresion</span>
<span xsmall>(return val)</span>
val result = 
  try { count() } 
  catch (e: ArithmeticException) {
    throw RuntimeException(e) 
  }
</pre>

<pre zoom >
<span xsmall>Ranges</span>
- Interval with start and end value. Any comparable type can be used.
val aToZ = "a"º..º"z" // "c" in aToZ == true
val countingDown = 100.downTo(0)
val ten20 = 10.rangeTo(20).step(2)
</pre>
</div>

<div groupv>
<pre title>
Strings
</pre>
<pre zoom>
<span xsmall>String</span>
<span xsmall>template</span>
val a  = 23
val s1 = "Hello World º$aº!"
println(s1)
</pre >

<pre zoom>
<span xsmall>String</span>
<span xsmall>Expresions</span>
  
"col1: º${ºs1.replace("A", "B")º}º $d"
</pre >

<pre zoom>
<span xsmall>Multiline</span>
<span xsmall>string with </span>
<span xsmall>margin</span>
  val myMultiLineString = """
º    |º for (c in "foo")
º    |º     print(c)
º    |º Dolar is writen as ${'$'}
  """.ºtrimMargin()º // remove leading spaces.
  print(myMultiLineString)
</pre>
</div>

<div groupv>
<pre title>
Collections
</pre>
<pre zoom>
<span xsmall>Initializing</span>
<span xsmall>Collections</span>
val array1 : Array<String> = ºarrayOfº("asdf","ADF")
val emptyStringArray = arrayOf<String>()
val intArray = arrayOf(1,2,3)
val doubleList : List<Double>= arrayListOf(84.88, ...)
var nonNulls: List<String> = 
                  listOfNotNull<String>{null, "a",...}
val map1 = mapOf("a" to 1, "b" to 2)
val map2 = mapOf(Pair("a", 1), Pair("b", 2))
println(map1) // Prints [1, 2]

val intSet: Set<Int> = setOf(1, 2, 1,..)    
val hashSet: java.util.HashSet˂Book˃ = 
    hashSetOf(Book(...), Book(...)
val longSet: MutableSet˂Long˃ = mutableSetOf( 1, 2, 3)

val readWriteList: MutableList˂String˃ =
                      mutableListOf(...)
val readOnlyView : List˂String˃ = readWriteList

// array-lambda-init
val squaredArray: Array = 
    Array(5, º{ idx -˃ (idx º idx).toString() }*)
</pre>
<pre zoom>
<span xsmall>Walk-over</span>
<span xsmall>/iterate</span>
// iterate through elements
// Alt 1:
sequence.ºforEachº { it*it }

// Alt 2:
for (ºitem inº myArrayOrList) println("${item}")

// "walk" by index 
for (ºidx  in intList.indicesº)
  println("$idx is ${intList[idx]}")
</pre>
<pre zoom >
<span xsmall>spread array</span>
val    a = asList(1, 2, 3)
val list = asList(-1, 1, ºaº /*spread*/, 4)  
</pre>
<pre zoom >
<span xsmall>Filtering a list</span>
val positives = listº.filterº { x -˃ x ˃ 0 }
// even shorter: (using default "it")
val positives = list.filter { it ˃ 0 }
</pre >

<pre zoom >
<span xsmall>Interfaces</span>

interface MyInterface {
    val prop1: Int 
    val prop2: String
        ºget() = "foo"º // default accessor
    fun bar(): Int
    // default implementation
    fun foo() { print(prop)  } 
    fun foo() { }
}

class Child : MyInterface {
  override val prop: Int = 29
}
</pre>

<pre zoom>
<span xsmall>Single method</span>
<span xsmall>Iface pattern</span>
- (An interface with a single method: Runnable, Callable, Closeable, Comparator, ...).
  Kotlin has support for converting a function literal directly
  into a SAM. If the conversion is unambiguous, you can simply pass the function literal
  where a SAM is expected:
val threadPool = Executors.newFixedThreadPool(4)
threadPool.submit {
  ºprintln("...")º
}
// The kotlin compiler will convert this code to:
threadPool.submit(
 ºobject : Runnable {  º
 º override fun run() {º
 º   println("...")    º
 º }                   º
 º}                    º
)
</pre>

</div>

<pre zoom { >
<span xsmall bgorange>functions</span>
-@[https://kotlinlang.org/docs/reference/functions.html]
data class Coordinate(val x: Int, val y: Int)

fun getPoint
   (a: Int, b: Int º= 1 /*def.valº/*, ºvarargº names: String) : Coordinate {   
  return Coordinate(a+b,a-b)
}                                
// "shortcut"
fun getPoint(a: Int, b: Int = 1) º= Coordinate(a+b,a-b)º
// ussage, split vl
val (x, y) = getPoint(1,2)
// Using named parameters
val (x, y) = getPoint(a = 1, b = 2)

ºGeneric Functionsº
// ˂T˃ is specified before the fun. name
fun ˂T˃ singletonList(item: T): 
  List˂T˃ {
    // ...
}

ºTail recursiveº
// ºCompiler optimises out the recursion!!!º
// - function must call itself as last operation)
// - doesn't work  within try/catch.
// - only supported in JVM (currently)
tailrec 
fun findFixPoint(x: Double = 1.0): Double
  = if (x == Math.cos(x)) x 
    else findFixPoint(Math.cos(x))

<a orange href="https://kotlinlang.org/docs/reference/inline-functions.html">Inline functions</a>
inline 
  fun lock(param1: Class1, ...) :
  ReturnClass {
}

º(Class)Extension Functionsº
fun OºString.ºspaceToCamelCase()
    String { ... }
(String. == Applies only to String objects)
Ussage:
"to camelcase".spaceToCamelCase()
23424.spaceToCammelCase() // Compiler error

ºFunctions receiversº
/* 
 * Very similar to extension functions but applies to func. literals.
 * that is, to variables representing functions.
 */
// Definition:
val countChars: OºString.º() -˃ Unit = { println("Counted chars: ${length}") }
// Ussage:
val txt = "ASDF"
countChars(Oºtxtº)

ºInfix Member Functionsº
class Account {
  var balance = 0.0
  ºinfixº fun add(amount:Double): Unit {
     this.balance = balance + amount
  }
}
accountInstance add 100.00

ºOperator Overloadingº
Allowed for 
class     |
Operation | Function name
a + b     | plus()
a – b     | minus()
A * b     | times()
A / b     | div()
A ⅋ b     | mod()
a..b      | rangeTo()
+a        | unaryPlus()
-a        | unaryMinus()
!a        | not()
[p1,p2,..]| operator fun get(param1, param2,...)
˂ ˂=      | compareTo
˃ ˃=      |
-------------------------
()        | operator func invoke():

// ˂- instance 'space':'space' =˃ type ←→ supertype
interface Foo˂out T : Any˃ : Bar {
// ← instance: =˃ instance ←→ type
    fun foo(a: Int): T 
}

OºHigh Order Functsº
ºFunction receiving a functionº
fun foo(name: String, ºparamFunc: (String) -˃ Stringº): Unit {
  val applied = paramFunc(name)
  println(applied)
}
foo("hello", ºparamFunc = { it.reversed() }º)


ºFunction returning a functionº
fun bar() :
   º(String) -˃ String = { str -˃ str.reversed() }º

ºClosuresº
fun students(nameToMatch: String): List˂Student˃ {
  return loadStudents().filter {
   *// closure has access to parent stack*
   ºit.lastName == nameToMatch           º
  }
}

ºCurrying functionsº
<span TODO>TODO</span>

ºMemoization (Avoid repeated long-running calculus)º
fun Function1º.memoized()º: (String) -˃ MyClass {
  val map = ConcurrentHashMap˂String, MyClass˃()
  return {
    a -˃ map.getOrPut(a) {
      this.invoke(a)
    }
  }
}
</pre>

<div groupv>
<pre zoom>
<span xsmall>Classes</span>
@[https://kotlinlang.org/docs/reference/classes.html]
-Oº"Any"º (common superclass in Kotlin) is ºNOTº java.lang.Object; 
  it does not have any members other than equals(), hashCode() and toString().

- By default classses are final. Use open class ... to make non-final

<span xsmall>Composition</span>
<span xsmall>over</span>
<span xsmall>inheritance</span>
- sometimes called delegation, where delegation is actually the dessign pattern 
      and composition the standard/easiest way to implement it.
- REF1:"Efective Java"
- REF2:<a href="https://kotlinlang.org/docs/reference/delegation.html">Kotlin doc ref</a><li/>
- Note: foreign keys in SQL is the best well known form of composition:
employee      person     client
--------      -------    ------
id      ←─┐┌─→ id   ←─┐  id
roll      ││   name   └─ fk_person
fk_person ─┘   ...    ┌─ fk_saleManager
...       └───────────┘   ...

<span xsmall>Composition</span>
interface IPerson { fun print() ... }

class Person(val name: String, val familyName1: ...) : IPerson {
  override fun print() { print(x) }
}

class Employee(b: IPerson) : IPerson Oºbyº b

fun main(args: Array˂String˃) {
    val pacoMA = Person(
             surname:"Paco", name1: "Martinez", ... )
    val employee = Employee(
                    ºperson: pacoMA,º
                     roll: manager,
                     ... )
    employee Oº.print()º /* == myClass.base.print() */
}

<span xsmall>Inheritance</span>
<span xsmall>(discouraged)</span>
class Derived(p: Int) Oº:º Base(p)

class Container(
  id     : Int, 
  size   : Int,
  childs : Containers
) : SuperClass(id, name),
  Iface1, Iface2, Iface3 {
  var person_id = id
O*// custom accesor*
  val isEmpty: Boolean 
    Oºget() = this.size == 0  º
    Oº       || (var sum = 0; for (c in childs) sum+=c.size) == 0º
  val stringRepr : String
      ºget() = this.toString()º
      ºset(value) = _setFromString(value)º
  // ...

  ºcompanion objectº Factory : FactoryTemplate˂MyClass˃ { // ← object name ('Factory') can be ommited
    override fun create(): Container = Container(...)
  }
  }
  val instance = MyClass.create()
}

<span xsmall>Singleton</span>
Oºobjectº Resource {
  val name = "Name"
  fun method1(...) {
          // ...
  }
}
Resource.method1(...)

<span xsmall>Compaq class</span>
<span xsmall>declaration</span>
// use val or var:      |Oºconstructorº keyword optional if no 
class Person(           |  annotations and default visibility  applies
  val firstName: String,|  class Customer 
  val lastName: String, |    public @Inject Oºconstructorº(
  var age: Int) {       |      val name: String = "") 
  ...                   |  { 
}                       |      ...
                        |      init { // 'init' marks an initializer block
                        |          logger.info("initialized with ${name}")
                        |      }
                        |      /* (Secondary) */
                        |      constructor(parent: Person) {
                        |        parent.children.add(this)
                        |    }
                        |  }

<span xsmall>data class</span>
<span xsmall>(DTO)</span>
<span comment>automatically generates:
- getters (and setters for vars),
- equals(), hashCode(), toString(), copy()
- component1(),… for all properties 
</span>
Oºdataº class Customer(
  val name  : String,  // val: inmutable
  val email : String, // val: inmutable
  var refNum: Int )    // var:   mutable 
Q*// optional class member functions *
Qº{º
Qº  override fun toString() : String {º
Qº    return "(${refNum} : ${name} ˂${email}˃)"º
Qº  }º
Qº}º

<span xsmall>Sealed Class</span>
@[https://kotlinlang.org/docs/reference/sealed-classes.html]
- represent restricted class hierarchies or "sort of" enum extensions,
  with subclasses being able to have multiple instances.
- (sealed class/subclasses must be declared in the same file)
Declaration:
ºsealedº class Expr
data class Const(val number: Double)      º: Expr()º
data class Sum(val e1: Expr, val e2: Expr)º: Expr()º
object /*singleton*/ NotANumber º: Expr()º

Ussage:
fun eval(expr: ºExprº): Double =
  when(expr) {
  is ºConstº      -˃ expr.number
  is ºSumº        -˃ eval(expr.e1) + eval(expr.e2)
     ºNotANumberº -˃ Double.NaN
}

<span xsmall>Inner class</span>
Object expressions are a generalization of anonymous inner classes:
// Ex1:
window.addMouseListener( 
  Oºobject : ListenerBaseº(
    baseClassConstructorParam1,
    ...) {
      override fun onMouseClicked(e: MouseEvent) { ... }
    })
// Ex2:
interface B {...}
val ab: A = object : A(1), B { override ...  }
</pre>
</div>

<div groupv>
<pre zoom labels="qa">
<span xsmall>DSL</span>
- <a href="https://blog.jetbrains.com/kotlin/2011/10/dsls-in-kotlin-part-1-whats-in-the-toolbox-builders/">REF</a>,
<a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">REF 2</a> 
Examples
- <a href="https://github.com/Kotlin/kotlinx.html">Kotlin DSL for HTML</a>
- <a href="https://github.com/Kotlin/anko/wiki/Anko-Layouts">Programatically generate layouts</a>
- <a href="https://ktor.io/features/routing.html#routing-tree">Defining (Web server) routing trees</a>
</pre>
<pre zoom>
<span xsmall>Syntactic sugar</span>
- Allow to conver code like:
  Collection.sort(ºlistº);
  int index = Collection.binarySearch(ºlistº,x);
into 
 ºlistº.sort();
  int index = ºlistº.binarySearch(x);

- providing IDE autocompletion by just writing an object instance. 
  (No need to be aware of Collection object)
  - All that needed is code like:
// Restrict fun ˂T : Comparable˂T˃˃ sort() to List elements 
// i.e., only to elements compatibles with OºCollections.sort(...)º

fun ˂T : Comparable˂T˃˃ ºList˂T˃.ºsort() {
   Collections.sort(this)
}
  
- Infix functions allows to convert
 ºhasPrivilegeº(Gºitº, WRITE) 
into
  /* human friendly "subject" + verb + "predicate" */
Gºitº ºhasPrivilegeº WRITE  
  
- Code like
  lock(myLock, Oº{...}º)

can be written like 
(last Oºfunct.literalº can be put outside the parenthesis):
  lock(myLock), Oº{...}º
  
- Another convention: If a function with only one parameter is expected,
  the parameter declaration may be omitted, and the default name "it" will be used. 
  Code like 
  filter { it =˃ it.foo()}
can be "shortcuted" to:
  filter { it.foo()}
</pre>

<pre zoom labels="qa">
<span xsmall>Ex "HTML"</span>
<span xsmall>DSL</span>
import com.example.html.* // see declarations below

fun result(args: Array<String>) =
  html /* 1 */ {
    /*Bºthis. HTML instanceº*/ head {
        title {+"XML encoding with Kotlin"}
    }
    /*Bºthis. HTML instanceº*/ body {
      h1 {+"XML encoding with Kotlin"}
      p  {+"this format can be used as an alternative markup to XML"}

      // an element with attributes and text content
      a(href = "http://kotlinlang.org") {+"Kotlin"}

      // mixed content
      p {
        +"This is some"
        b {+"mixed"}
        +"text. For more see the"
        a(href = "http://kotlinlang.org") {+"Kotlin"}
        +"project"
      }
      p {+"some text"}

      // content generated by
      p {
        for (arg in args)
          +arg
      }
    }
  }

/* 1 call to html function defined as: */
fun html(Oºinitº: HTML.() -˃ Unit): HTML {
    val BºhtmlInstance = HTML()º // init reciever 
    htmlInstance.Oºinitº()
    return htmlInstance
}

protected fun ˂T : Element˃ initTag(GºtagInstanceº: T, Oºinitº: T.() -˃ Unit): T {
    GºtagInstanceº.Oºinitº()
    /*Bºthis. parent Tag instanceº*/.add(GºtagInstanceº)
    return GºtagInstanceº
}

fun head(Oºinitº: Head.() -˃ Unit)  = initTag(Head(), Oºinitº) 
fun body(Oºinitº: Body.() -˃ Unit)  = initTag(Body(), Oºinitº)

operator fun String.unaryPlus() {
    children.add(TextElement(this))
}
</pre>

<pre zoom labels="performance,comparision">
<span xsmall>Coroutines</span>
@[https://kotlinlang.org/docs/reference/coroutines.html]
- experimental starting with v.1.1+ 
- See also Design documents and examples for coroutines in Kotlin
@[https://github.com/Kotlin/kotlin-coroutines]
@[https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#composing-suspending-functions]
- Basically, coroutines are computations that can be suspended without blocking
  a thread.
  - Suspension can be controlled by a user library to a large extent deciding 
    what happens upon suspension and optimize/log/intercept according to our needs.

- Compared to threads, coroutines can not be suspended at random instructions, 
  but rather only at defined suspension points, which are calls to specially 
  marked functions
// Oºsuspendº marks the function as a suspension point
// can ONLY be called from coroutines and other suspending functions

Oºsuspendº funs doSomething(foo: Foo): Bar {
    ...
}
  
- To start a coroutine, there must be at least one suspending function,
    and it is usually a suspending lambda. Ex:
// Ex.simplified async() function (from kotlinx.coroutines library):
fun ˂T˃ async(Bºblockº:      suspend () -˃ T)
//      ^                 +----------------+                  
//      +async() is a     lambda suspendable funct
//      regular function 

Ussage:
async {
    doSomething(foo)
    ...
}
  
- Continuing with the analogy, await() can be a suspending function
     that suspends a coroutine until some computation is done and returns its 
     result:
async {
    ...
    val result = computation.await()
    ...
}
  
- Async blocking calls are expressed sequentially with coroutines, and the underlying 
   library will take care of any complexity (wrap relevant parts into callbacks, subscribing
   to relevant events, scheduling execution on different threads (or even different machines!)
- Can be used to implement async mechanisms like async/await in C#/ECMAScript, channels/select in Go,
    and generators/yield in C#/Python
- Note that suspending functions await() and doSomething() cannot be called from function
literals that are not inlined into a suspending function body and from regular function like main():
fun main(args: Array˂String˃) {
    doSomething() // ERROR: Suspending function called from a non-coroutine context 
    
    async { 
        ...
        computationsOº.forEach {º
            // `forEach` is an inline function, the lambda is inlined
            it.await() // OK
      Oº}º
            
      Rºthread {º
            // `thread` is not an inline function, so the lambda is not inlined
            doSomething() // ERROR
      Rº}º
    }
}
  
- @RestrictsSuspension to prevent users from adding new ways of suspending a coroutine
@RestrictsSuspension
public abstract class SequenceBuilder˂in T˃ {
    ...
}
     When a receiver class or interface R is annotated with it, all suspending extensions
   are required to delegate to either members of R or other extensions to it. 
   Since extensions can't delegate to each other indefinitely (the program would
   not terminate), this guarantees that all suspensions happen through calling 
   members of R that the author of the library can fully control.
  


<span xsmall>inner workings</span>
- Coroutines are completely implemented through a compilation technique 
    º(no support from the VM or OS side is required)º, and suspension
    works through code transformation. Briefly, every suspending function
    is transformed to a state machine where states correspond to suspending
    calls. Right before a suspension, the next state is stored in a field of
    a compiler-generated class along with relevant local variables, etc. 
    Upon resumption of that coroutine, local variables are restored and the 
    state machine proceeds from the state right after suspension.
  
- A suspended coroutine can be stored and passed around as an object 
    that keeps its suspended state and locals. The type of such objects is
    Continuation, and the overall code transformation described here corresponds to 
    the classical Continuation-passing style. Consequently, suspending functions
    take an extra parameter of type Continuation under the hood.
</pre>
 
<pre zoom>
<span xsmall>buildSequence()</span>
- Kotlin v.1.2.41+
- Implement generators, cheap way to build a lazy/on-demand sequence:
// See also buildIterator(). Similarly to buildSequence() but returns a lazy iterator
val fibonacciSeq = buildSequence {
    var a = 0
    var b = 1
    yield(1)
    while (true) {
        yield(a + b)
        val tmp = a + b
        a = b
        b = tmp
    }
}

// Ex ussage:
fibonacciSeq.take(8).toList() // == [1, 1, 2, 3, 5, 8, 13, 21]
  
- To yield a collection (or sequence) of values at once use yieldAll():
val lazySeq = buildSequence {
    yield(0)
    yieldAll(1..10) 
}
  
</pre>
<pre zoom labels="performance">
<span xsmall>kotlinx.coroutines</span>
@[https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md]
- This mostly consists of core primitives and interfaces that all coroutine-based
    libraries are likely to use covering
  - Platform-agnostic asynchronous programming with kotlinx-coroutines-core,
      including Go-like channels that support select and other convenient
      primitives
  - APIs based on CompletableFuture from JDK 8: kotlinx-coroutines-jdk8
  - Non-blocking IO (NIO) based on APIs from JDK 7 and higher: kotlinx-coroutines-nio
  - Support for Swing (kotlinx-coroutines-swing) and JavaFx (kotlinx-coroutines-javafx)
  - Support for RxJava: kotlinx-coroutines-rx
</pre>
</div>

<div groupv>
<pre zoom>
<span xsmall>Micro-shell</span>
<span xsmall>(REP Loop)</span>
//  reads, tokenise and execute command

// https://discuss.kotlinlang.org/t/k2jvmcompiler/3629
private val REGEX_WHITESPACE_SEPARATED_TOKENS = Regex("[ \t]+")

// returns all tokens delimited by whitespace
private fun OºparseLineº(shellInput : String) : List˂String˃ =
    shellInput.split(REGEX_WHITESPACE_SEPARATED_TOKENS).filter { !it.isEmpty()}

private fun _command01(args : List˂String˃) = /* ... */ "OK"
private fun _command02(args : List˂String˃) = /* ... */ "OK"

private val USSAGE = """USSAGE EXAMPLES: ...""".trimMargin()

fun main(args: Array˂String˃) {
    Oºwhile (true) { // MAIN LOOPº
        print("~ ") // print shell prompt
        val lineTokens = parseLine(readLine() ?: continue)
        if (lineTokens.size == 0) continue
        val action = lineTokens[0]
        if ( action == "quit") break
        val args : List˂String˃ = if (lineTokens.size == 0) listOf() else
            lineTokens.subList(1,lineTokens.size)

        val ouput : String = if (false) ""
            else if (action == "command01" ⅋⅋ args.size˃=1) _command01(args)
            else if (action == "command02" ⅋⅋ args.size˃=1) _command02(args)
            else USSAGE
        System.err.println(ouput)
    Oº}º
}
</pre>

<pre zoom labels="">
<span xsmall>kscript</span>
@[https://github.com/holgerbrandl/kscript]
(Kotlin as script lang)
See also <a href="https://holgerbrandl.github.io/kscript_kotlinconf_2017/kscript_kotlinconf.html#1">Presentation@KotlinConf2017</a>
- Compiled script caching (using md5 checksums)</li>
- Dependency declarations using gradle-style resource locators and automatic dependency resolution with maven
- More options to provide scripts including interpreter mode, reading from stdin, local files or URLs
- Embedded configuration for Kotlin runtime options
- Support library to ease the writing of Kotlin scriptlets
- Deploy scripts as stand-alone binaries
</pre>
</div>


</body>
</html>
<!--
TODO_start
TODO: Lazy property:
  val p: String by lazy { // compute the string }

__________________________
TODO: If you need to write a function that can be called without having a class instance
but needs access to the internals of a class (for example, a factory method), you
can write it as a member of an object declaration
(https://kotlinlang.org/docs/reference/object-declarations.html) inside that class.
Even more specifically, if you declare a companion object 
(https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects) 
inside your class, you'll be able to call its members with the same syntax as calling
static methods in Java/C#, using only the class name as a qualifier.
____________________________
Use Kotlin with npm, webpack and react:
  https://blog.jetbrains.com/kotlin/2017/04/use-kotlin-with-npm-webpack-and-react/
____________________________
<span xbig>// Checking ranges:</span>
<pre>
if (x in 1...y+1) { println("OK") } 

for (x in 1..10       step 2) { print(x) }
for (x in 10 downTo 0 step 2) { print(x) }
for (idx          in array.indices)     { println(array[idx])       }
for ((idx, value) in array.withIndex()) { println("$idx -> $value") }
for ((key, value) in map              ) { println("$key -> $value") }
fruits.filter { it.startsWith("a") }.sortedBy { it }.
    map { it.toUpperCase() }.forEeach( println(it) )

val arrayOfMinusOnes: Array = IntArray(20).apply{fill(-1)} // 
</pre >

____________________________
<pre>
fun foo() {
  // Alt 1. lambda function
  ints.forEach lit@ {
    // returns from foo
    if (it == 0) return
    // returns from lambda lit@
    if (it == 1) return@lit
    // returns from lambda lit@ (implicit label)
    if (it == 2) return@forEach
    print(it)
  }
  // Alt 2. anonymous function
  ints.forEach( func(value: Int) {
    // local returns from  anonymous funct
    if (it == 0) return
    print(value)
  }
}
_______________________
mainLoop@ for (i in 1..100) { // <- any expresion can be marked with a  label ("identifier"@)
  for (j in 1..100) {
    if (j == 55) break@loop // jumps right after the loop marked with label
  }
}
</pre>


<!--
<a href="http://kotlinlang.org/api/latest/kotlin.test/index.html">kotlin.test</a>, included out of the box in Kotlin 1.2, lets you write your test once and run it under both the JVM and JS;
<a href="https://github.com/kotlin/kotlinx.html">kotlinx.html</a> supports <strong>isomorphic rendering</strong> – using the same code to render HTML in the backend and in the frontend;
<a href="https://github.com/kotlin/kotlinx.serialization">kotlinx.serialization</a> allows you to easily marshal Kotlin objects between different tiers of your application, using JSON or ProtoBuf as serialization formats.

What's new in Koltin 1.2:
http://kotlinlang.org/docs/reference/whatsnew12.html

____________________
Warnings as errors

The compiler now provides an option to treat all warnings as errors. Use -Werror on the command line, or the following Gradle snippet:

compileKotlin {
    kotlinOptions.allWarningsAsErrors = true
}
__________________________
https://kotlinlang.org/docs/reference/native-overview.html

https://github.com/JetBrains/kotlin-native/blob/master/samples/tensorflow/src/main/kotlin/HelloTensorflow.kt


__________________
<pre zoom labels="">
<span xsmall></span>
https://kotlin.es/2015/11/kotlin-koans-repositorio-de-ejercicios-oficiales/#
<p>###Introduction [13/42] Koans</p>
- <a href="https://github.com/vicboma1/Kotlin-Koans#hello-world">Hello World!</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#java-to-kotlin-conversion">Java to Kotlin conversion</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#named-arguments">Named arguments</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#default-arguments">Default arguments</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#lambdas">Lambdas</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#strings">Strings</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#data-classes">Data classes</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#nullable-types">Nullable types</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#smart-casts">Smart casts</a> ˂? Nivel 1
- <a href="https://github.com/vicboma1/Kotlin-Koans#extension-functions">Extension functions</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#object-expressions">Object expressions</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#sam-conversions">SAM conversions</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#extensions-on-collections">Extensions on collections</a>
</pre>
<p>###Collections [25/42] Koans</p>
- <a href="https://github.com/vicboma1/Kotlin-Koans#introduction">Introduction</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#filter-map">Filter map</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#all,any,count,firstornull">All, Any, Count, FirstOrNull</a> ˂? Nivel 2
- <a href="https://github.com/vicboma1/Kotlin-Koans#flatmap">FlatMap</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#maxmin">Max min</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#sort">Sort</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#sum">Sum</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#group-by">Group by</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#partition">Partition</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#fold">Fold</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#compoundtasks">Compound tasks</a> ˂? Nivel 3
- <a href="https://github.com/vicboma1/Kotlin-Koans#getusedtonewstyle">Get used to new style</a>
<p>###Conventions [32/42] Koans</p>
- <a href="https://github.com/vicboma1/Kotlin-Koans#comparison">Comparison</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#in-range">In range</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#range-to">Range to</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#for-loop">For loop</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#operators-overloading">Operators overloading</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#multi-assignment">Multi assignment</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#invoke">Invoke</a> ˂? Nivel 4
<p>###Properties [36/42] Koans</p>
- <a href="https://github.com/vicboma1/Kotlin-Koans#properties">Properties</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#lazy-property">Lazy property</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#delgates-examples">Delegates examples</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#delegates-how-it-works">Delegates how it works</a>
<p>###Builders [41/42] Koans</p>
- <a href="https://github.com/vicboma1/Kotlin-Koans#extension-function-literals">Extension function literals</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#string-and-map-builders">String and map builders</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#the-function-with">The function with</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#html-builders">Html builders</a>
- <a href="https://github.com/vicboma1/Kotlin-Koans#builders-how-it-works">Builders how it works</a>
_________________
https://blog.plan99.net/kotlin-fp-3bf63a17d64a
Kotlin "loves" Functional Programming
_________________
https://www.infoq.com/news/2018/08/airbnb-mvrx-android-framework
https://github.com/airbnb/MvRx/wiki

    Kotlin
    Android Architecture Components
    RxJava
    React (conceptually)
    Epoxy (optional but recommended)
__________________________
https://medium.com/blockchain-engineering/kotlin-akka-part-1-hello-kotlin-a0c0de7d7407
___________________________
REF: https://www.infoq.com/news/2018/10/kotlin-pinterest
InfoQ: What organizational challenges did Pinterest face during the adoption of Kotlin? How did Pinterest overcome these challenges?

    Lee:  One of the biggest challenges we faced during the adoption of Kotlin was ongoing issues with Kapt (the Kotlin annotation processor) and other build related issues. We would find ourselves with errors in our CI build environs, as well as frequent build failures when switching branches locally because build state was not getting properly cleared out. There was a point where some senior engineers were even advocating removing the language because of these problems. Some of these difficulties were the growing pains of adopting a young language -- Kapt itself had bugs and flaws that were inherent in the tool -- and not something anyone in our org could fix. These types of issues resolved as Kapt and the associated build tools improved, but in many engineers' minds, Kotlin was associated with build instability, which colored their opinion of the language. 

    However, another portion of these issues was a result of the inevitable blind spots that come when working with a new technology for the first time. These were issues that we had the ability to solve internally, and we did so through a concerted focus on education. An example of this was a common issue we saw at compile time where a developer would forget an import statement or make some other error unrelated to Kotlin but would have difficulty finding this error in the build output because of the way Kapt was outputting information in Android Studio. Teaching people where to find the real compile-time error gave them the knowledge necessary to navigate such failures on their own. To help with this class of issues, the team set up several Slack channels specifically for asking questions about Kotlin or the build and set a precedent that all questions were always welcome and would be responded to. Teaching the team how new components such as Kapt worked, what certain types of errors signaled, and where to start looking for resolutions went a long way in easing the pain of the transition. 
___________________________
https://es.slideshare.net/IldarNurgaliev/kotlin-compiler-construction-very-brief
________________________
https://blog.jetbrains.com/kotlin/2018/09/kotlin-1-3-rc-is-here-migrate-your-coroutines
___________________
https://blog.jetbrains.com/kotlin/2017/12/kotlinnative-v0-5-released-calling-kotlin-from-swift-and-c-llvm-5-and-more/
Kotlin/Native v0.5 released: calling Kotlin from Swift and C, LLVM 5 and more
___________________
https://developers.redhat.com/blog/2018/12/24/using-a-kotlin-based-grpc-api-with-envoy-proxy-for-server-side-load-balancing/
____________
https://javalin.io
_________________________
https://www.infoq.com/articles/kotlin-multiplatform-ios-developers/
Kotlin Multiplatform for iOS Developers 

Using Kotlin Multiplatform, you can avoid repeating lots of logic to develop an app running on multiple platforms.
KMP is not the final step to accomplishing 100% shared code across all platforms since UI logic must still be programmed natively in many cases because it is too platform-specific to share.
The close similarities between Swift's and Kotlin's syntax greatly reduces a massive part of the learning curve involved with writing that KMP business logic.
You can use Android Studio to create a reusable KMP component that you later import into an Xcode project as a framework.
__________________
https://allegro.tech/2018/05/From-Java-to-Kotlin-and-Back-Again.html
_________________________
https://kotlinlang.org/docs/reference/sequences.html
long with collections, the Kotlin standard library contains another container type – sequences (Sequence<T>). Sequences offer the same functions as Iterable but implement another approach to multi-step collection processing.

When the processing of an Iterable includes multiple steps, they are executed eagerly: each processing step completes and returns its result – an intermediate collection. The following step executes on this collection. In turn, multi-step processing of sequences is executed lazily when possible: actual computing happens only when the result of the whole processing chain is requested.

The order of operations execution is different as well: Sequence performs all the processing steps one-by-one for every single element. In turn, Iterable completes each step for the whole collection and then proceeds to the next step.

So, the sequences let you avoid building results of intermediate steps, therefore improving the performance of the whole collection processing chain. However, the lazy nature of sequences adds some overhead which may be significant when processing smaller collections or doing simpler computations. Hence, you should consider both Sequence and Iterable and decide which one is better for your case.
-->
